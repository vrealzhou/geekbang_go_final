// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package servestale

import (
	context "context"
	api "github.com/vrealzhou/geekbang_go_final/api"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// MusicClient is the client API for Music service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MusicClient interface {
	// Get artist by arid
	UpdateArtist(ctx context.Context, opts ...grpc.CallOption) (Music_UpdateArtistClient, error)
	// Get release information by arid
	UpdateRelease(ctx context.Context, opts ...grpc.CallOption) (Music_UpdateReleaseClient, error)
	// Get recording information by arid
	UpdateRecording(ctx context.Context, opts ...grpc.CallOption) (Music_UpdateRecordingClient, error)
	// Get artwork by arid
	UpdateArtwork(ctx context.Context, opts ...grpc.CallOption) (Music_UpdateArtworkClient, error)
}

type musicClient struct {
	cc grpc.ClientConnInterface
}

func NewMusicClient(cc grpc.ClientConnInterface) MusicClient {
	return &musicClient{cc}
}

func (c *musicClient) UpdateArtist(ctx context.Context, opts ...grpc.CallOption) (Music_UpdateArtistClient, error) {
	stream, err := c.cc.NewStream(ctx, &Music_ServiceDesc.Streams[0], "/servestale.Music/UpdateArtist", opts...)
	if err != nil {
		return nil, err
	}
	x := &musicUpdateArtistClient{stream}
	return x, nil
}

type Music_UpdateArtistClient interface {
	Send(*api.Artist) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type musicUpdateArtistClient struct {
	grpc.ClientStream
}

func (x *musicUpdateArtistClient) Send(m *api.Artist) error {
	return x.ClientStream.SendMsg(m)
}

func (x *musicUpdateArtistClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *musicClient) UpdateRelease(ctx context.Context, opts ...grpc.CallOption) (Music_UpdateReleaseClient, error) {
	stream, err := c.cc.NewStream(ctx, &Music_ServiceDesc.Streams[1], "/servestale.Music/UpdateRelease", opts...)
	if err != nil {
		return nil, err
	}
	x := &musicUpdateReleaseClient{stream}
	return x, nil
}

type Music_UpdateReleaseClient interface {
	Send(*api.Release) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type musicUpdateReleaseClient struct {
	grpc.ClientStream
}

func (x *musicUpdateReleaseClient) Send(m *api.Release) error {
	return x.ClientStream.SendMsg(m)
}

func (x *musicUpdateReleaseClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *musicClient) UpdateRecording(ctx context.Context, opts ...grpc.CallOption) (Music_UpdateRecordingClient, error) {
	stream, err := c.cc.NewStream(ctx, &Music_ServiceDesc.Streams[2], "/servestale.Music/UpdateRecording", opts...)
	if err != nil {
		return nil, err
	}
	x := &musicUpdateRecordingClient{stream}
	return x, nil
}

type Music_UpdateRecordingClient interface {
	Send(*api.Recording) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type musicUpdateRecordingClient struct {
	grpc.ClientStream
}

func (x *musicUpdateRecordingClient) Send(m *api.Recording) error {
	return x.ClientStream.SendMsg(m)
}

func (x *musicUpdateRecordingClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *musicClient) UpdateArtwork(ctx context.Context, opts ...grpc.CallOption) (Music_UpdateArtworkClient, error) {
	stream, err := c.cc.NewStream(ctx, &Music_ServiceDesc.Streams[3], "/servestale.Music/UpdateArtwork", opts...)
	if err != nil {
		return nil, err
	}
	x := &musicUpdateArtworkClient{stream}
	return x, nil
}

type Music_UpdateArtworkClient interface {
	Send(*api.Artwork) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type musicUpdateArtworkClient struct {
	grpc.ClientStream
}

func (x *musicUpdateArtworkClient) Send(m *api.Artwork) error {
	return x.ClientStream.SendMsg(m)
}

func (x *musicUpdateArtworkClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// MusicServer is the server API for Music service.
// All implementations must embed UnimplementedMusicServer
// for forward compatibility
type MusicServer interface {
	// Get artist by arid
	UpdateArtist(Music_UpdateArtistServer) error
	// Get release information by arid
	UpdateRelease(Music_UpdateReleaseServer) error
	// Get recording information by arid
	UpdateRecording(Music_UpdateRecordingServer) error
	// Get artwork by arid
	UpdateArtwork(Music_UpdateArtworkServer) error
	mustEmbedUnimplementedMusicServer()
}

// UnimplementedMusicServer must be embedded to have forward compatible implementations.
type UnimplementedMusicServer struct {
}

func (UnimplementedMusicServer) UpdateArtist(Music_UpdateArtistServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateArtist not implemented")
}
func (UnimplementedMusicServer) UpdateRelease(Music_UpdateReleaseServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateRelease not implemented")
}
func (UnimplementedMusicServer) UpdateRecording(Music_UpdateRecordingServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateRecording not implemented")
}
func (UnimplementedMusicServer) UpdateArtwork(Music_UpdateArtworkServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateArtwork not implemented")
}
func (UnimplementedMusicServer) mustEmbedUnimplementedMusicServer() {}

// UnsafeMusicServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MusicServer will
// result in compilation errors.
type UnsafeMusicServer interface {
	mustEmbedUnimplementedMusicServer()
}

func RegisterMusicServer(s grpc.ServiceRegistrar, srv MusicServer) {
	s.RegisterService(&Music_ServiceDesc, srv)
}

func _Music_UpdateArtist_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MusicServer).UpdateArtist(&musicUpdateArtistServer{stream})
}

type Music_UpdateArtistServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*api.Artist, error)
	grpc.ServerStream
}

type musicUpdateArtistServer struct {
	grpc.ServerStream
}

func (x *musicUpdateArtistServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *musicUpdateArtistServer) Recv() (*api.Artist, error) {
	m := new(api.Artist)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Music_UpdateRelease_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MusicServer).UpdateRelease(&musicUpdateReleaseServer{stream})
}

type Music_UpdateReleaseServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*api.Release, error)
	grpc.ServerStream
}

type musicUpdateReleaseServer struct {
	grpc.ServerStream
}

func (x *musicUpdateReleaseServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *musicUpdateReleaseServer) Recv() (*api.Release, error) {
	m := new(api.Release)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Music_UpdateRecording_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MusicServer).UpdateRecording(&musicUpdateRecordingServer{stream})
}

type Music_UpdateRecordingServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*api.Recording, error)
	grpc.ServerStream
}

type musicUpdateRecordingServer struct {
	grpc.ServerStream
}

func (x *musicUpdateRecordingServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *musicUpdateRecordingServer) Recv() (*api.Recording, error) {
	m := new(api.Recording)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Music_UpdateArtwork_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MusicServer).UpdateArtwork(&musicUpdateArtworkServer{stream})
}

type Music_UpdateArtworkServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*api.Artwork, error)
	grpc.ServerStream
}

type musicUpdateArtworkServer struct {
	grpc.ServerStream
}

func (x *musicUpdateArtworkServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *musicUpdateArtworkServer) Recv() (*api.Artwork, error) {
	m := new(api.Artwork)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Music_ServiceDesc is the grpc.ServiceDesc for Music service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Music_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "servestale.Music",
	HandlerType: (*MusicServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UpdateArtist",
			Handler:       _Music_UpdateArtist_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UpdateRelease",
			Handler:       _Music_UpdateRelease_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UpdateRecording",
			Handler:       _Music_UpdateRecording_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UpdateArtwork",
			Handler:       _Music_UpdateArtwork_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "internal/servestale/cache.proto",
}

// NewsClient is the client API for News service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NewsClient interface {
	// Get artist by arid
	UpdateArtcle(ctx context.Context, opts ...grpc.CallOption) (News_UpdateArtcleClient, error)
	// Get release information by arid
	UpdateCollection(ctx context.Context, opts ...grpc.CallOption) (News_UpdateCollectionClient, error)
	// Get recording information by arid
	UpdateImage(ctx context.Context, opts ...grpc.CallOption) (News_UpdateImageClient, error)
}

type newsClient struct {
	cc grpc.ClientConnInterface
}

func NewNewsClient(cc grpc.ClientConnInterface) NewsClient {
	return &newsClient{cc}
}

func (c *newsClient) UpdateArtcle(ctx context.Context, opts ...grpc.CallOption) (News_UpdateArtcleClient, error) {
	stream, err := c.cc.NewStream(ctx, &News_ServiceDesc.Streams[0], "/servestale.News/UpdateArtcle", opts...)
	if err != nil {
		return nil, err
	}
	x := &newsUpdateArtcleClient{stream}
	return x, nil
}

type News_UpdateArtcleClient interface {
	Send(*api.Article) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type newsUpdateArtcleClient struct {
	grpc.ClientStream
}

func (x *newsUpdateArtcleClient) Send(m *api.Article) error {
	return x.ClientStream.SendMsg(m)
}

func (x *newsUpdateArtcleClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *newsClient) UpdateCollection(ctx context.Context, opts ...grpc.CallOption) (News_UpdateCollectionClient, error) {
	stream, err := c.cc.NewStream(ctx, &News_ServiceDesc.Streams[1], "/servestale.News/UpdateCollection", opts...)
	if err != nil {
		return nil, err
	}
	x := &newsUpdateCollectionClient{stream}
	return x, nil
}

type News_UpdateCollectionClient interface {
	Send(*api.CollectionResponse) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type newsUpdateCollectionClient struct {
	grpc.ClientStream
}

func (x *newsUpdateCollectionClient) Send(m *api.CollectionResponse) error {
	return x.ClientStream.SendMsg(m)
}

func (x *newsUpdateCollectionClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *newsClient) UpdateImage(ctx context.Context, opts ...grpc.CallOption) (News_UpdateImageClient, error) {
	stream, err := c.cc.NewStream(ctx, &News_ServiceDesc.Streams[2], "/servestale.News/UpdateImage", opts...)
	if err != nil {
		return nil, err
	}
	x := &newsUpdateImageClient{stream}
	return x, nil
}

type News_UpdateImageClient interface {
	Send(*api.Image) error
	CloseAndRecv() (*emptypb.Empty, error)
	grpc.ClientStream
}

type newsUpdateImageClient struct {
	grpc.ClientStream
}

func (x *newsUpdateImageClient) Send(m *api.Image) error {
	return x.ClientStream.SendMsg(m)
}

func (x *newsUpdateImageClient) CloseAndRecv() (*emptypb.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(emptypb.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// NewsServer is the server API for News service.
// All implementations must embed UnimplementedNewsServer
// for forward compatibility
type NewsServer interface {
	// Get artist by arid
	UpdateArtcle(News_UpdateArtcleServer) error
	// Get release information by arid
	UpdateCollection(News_UpdateCollectionServer) error
	// Get recording information by arid
	UpdateImage(News_UpdateImageServer) error
	mustEmbedUnimplementedNewsServer()
}

// UnimplementedNewsServer must be embedded to have forward compatible implementations.
type UnimplementedNewsServer struct {
}

func (UnimplementedNewsServer) UpdateArtcle(News_UpdateArtcleServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateArtcle not implemented")
}
func (UnimplementedNewsServer) UpdateCollection(News_UpdateCollectionServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateCollection not implemented")
}
func (UnimplementedNewsServer) UpdateImage(News_UpdateImageServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateImage not implemented")
}
func (UnimplementedNewsServer) mustEmbedUnimplementedNewsServer() {}

// UnsafeNewsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NewsServer will
// result in compilation errors.
type UnsafeNewsServer interface {
	mustEmbedUnimplementedNewsServer()
}

func RegisterNewsServer(s grpc.ServiceRegistrar, srv NewsServer) {
	s.RegisterService(&News_ServiceDesc, srv)
}

func _News_UpdateArtcle_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NewsServer).UpdateArtcle(&newsUpdateArtcleServer{stream})
}

type News_UpdateArtcleServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*api.Article, error)
	grpc.ServerStream
}

type newsUpdateArtcleServer struct {
	grpc.ServerStream
}

func (x *newsUpdateArtcleServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *newsUpdateArtcleServer) Recv() (*api.Article, error) {
	m := new(api.Article)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _News_UpdateCollection_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NewsServer).UpdateCollection(&newsUpdateCollectionServer{stream})
}

type News_UpdateCollectionServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*api.CollectionResponse, error)
	grpc.ServerStream
}

type newsUpdateCollectionServer struct {
	grpc.ServerStream
}

func (x *newsUpdateCollectionServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *newsUpdateCollectionServer) Recv() (*api.CollectionResponse, error) {
	m := new(api.CollectionResponse)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _News_UpdateImage_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NewsServer).UpdateImage(&newsUpdateImageServer{stream})
}

type News_UpdateImageServer interface {
	SendAndClose(*emptypb.Empty) error
	Recv() (*api.Image, error)
	grpc.ServerStream
}

type newsUpdateImageServer struct {
	grpc.ServerStream
}

func (x *newsUpdateImageServer) SendAndClose(m *emptypb.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *newsUpdateImageServer) Recv() (*api.Image, error) {
	m := new(api.Image)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// News_ServiceDesc is the grpc.ServiceDesc for News service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var News_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "servestale.News",
	HandlerType: (*NewsServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UpdateArtcle",
			Handler:       _News_UpdateArtcle_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UpdateCollection",
			Handler:       _News_UpdateCollection_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UpdateImage",
			Handler:       _News_UpdateImage_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "internal/servestale/cache.proto",
}
