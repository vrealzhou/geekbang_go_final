# 毕业总结

这次Go训练营虽然和原来预想的内容有些出入，不过收获还是相当多的。这次课程涵盖了相当多的内容，从架构到Go语言的细节实现。所以课程结束以后还需要不断的回顾消化。

## 课程收获
### 微服务概览与治理
微服务已经是个很热的话题了，不过因为公司架构方面的原因，不可能在实际项目中大量实施。所以大部分是理论上的东西。课程里对理论上的东西结合老师的实践经验讲得很透彻，不过因为讲的内容和我工作中使用的具体技术栈有很大差别（我们现在是绑定在AWS上），所以还是需要课程结束以后具体消化一段时间。

触动最大的一点是微服务架构对DevOps的要求大大提高了，而且发现我个人对这方面的内容比较感兴趣。有可能会让我重新考虑将来的职业方向。不过无论是开发还是DevOps还是测试，始终是离不开写代码的，只是侧重点不同。但是DevOps需要对架构的理解和具体实现要超过业务开发人员。

### error处理
这个我们已经应用到现在项目里了。引入了errors包，做了一次比较大的重构。同时结合Go工程化里的日志的讲解，去掉了很大一部分多余的日志。直接收益就是日志方面的开销降低了。
之前有幸见过Dave Cheney本人，他给了一些error处理的建议(作为他对go语言一些缺点的例子)，和这节的内容是有相似之处的。

### 并发/并行
Goroutine是Go语言的核心功能之一，因为方便而且性能高所以会被滥用。之前工作中也测试过一些情况下使用Goroutine比串行处理更慢。
* Leave concurrency to the caller：尽量不要将并行操作分散在多个函数里，而是每个函数串行处理一个任务，由调用的地方负责编排并行逻辑
* Never start a goroutine without knowning when it will stop：为每个Goroutine提供优雅结束的途径，即使是监听端口这样的服务也要有。这样可以保证每个Goroutine完整的生命周期，减少内存泄露以及数据丢失。
* Memory Reordering：多核环境下，CPU的每个核为了性能会提前读取一些内容到缓存，如果没有锁，会导致很多很奇妙的bug。锁的重要性以及锁对性能产生影响的原因。
* atomic包：无锁的共享方式。
* channel：channel的性能并不像网上说的那么不堪，所以大部分情况下是可以放心使用的。缓冲区大小对性能的影响。
* errgroup：很实用的包。目前项目的业务需求暂时用不上（现在是遇到错误打日志然后继续处理其他的），但是如果有肯定第一时间会想到的。
* sync.Pool：对象池可以减少内存分配和gc，会考虑到项目中。

### Go工程化
Go的工程化方面有很多东西，这次总结出来的相当多。因为和我们现在使用的东西比较不同，所以了解了很多新的东西，应该会慢慢应用到现在的工作中去。不过还是需要一段时间来自己摸索，消化。
需要再消化的点：
* 同一个项目的多个微服务之间有些私有的通信api，这些api不应该和对外api放在一起。应该放在哪里。尤其是sidecar的api。
* Go的条件编译的使用

### 微服务可用性设计
这大概是这次训练营对我提升最大的一部分知识。在软件即服务的时代，对服务的可用性以及稳定性要求越来越高，而且需要承载的流量越来越大。作为后端工程师不可避免的要接触到这些内容。这些内容大部分是比较散的，变化也比较快，每年都有很多新的概念和技术出现。一般的后端工程师在工作中会有不同的侧重点，除非专注这方面，否则不大可能全面而且系统的了解。

这次训练营这方面的内容正好和我现在手头的一部分任务相关，所以可以直接运用在项目中，比如熔断器的实现细节，获益匪浅。

### Go语言网络编程
网络编程内容比较多，在课上只是大概了解。还需要再次回顾以及在实际中使用。写过Java版的Socket阻塞通信，所以相对了解一些，目前项目中没有用到的地方，需要自己写一些非阻塞的例子做更深入了解。
* 新了解了Http3的前景，UDP目前的问题。
* 非对称算法更安全但是性能低。HTTPS用非对称算法传递密钥，然后用对称算法传输内容。
* HTTP的不同版本的多路复用。
* Web socket的长连接。了解了简单原理，但是需要在复杂环境下测试具体的配置模式（CDN，负载均衡），实际写个小项目。

### 日志
过去总是有多打日志的冲动，想记录下所有的情况。实际使用中日志太多也会影响定位问题。
* 有意义的日志级别：Info，Error
* Warning：这点和老师看法不同，我们需要记录一些上游服务的数据错误（有人工数据，所以会出错），这些错误会发给上游团队修正，但是完全不会影响到我们的服务。我们使用Warning级别把这些问题提取出来。
* 集中的日志系统：我们使用的是SumoLogic，一个完全云端托管的系统，降低内部的人员开销。
* 日志格式：项目里使用了不少第三方系统，它们的日志格式是不统一的。感觉只能依赖更灵活的查询系统或者日志预处理。

### 链路追踪
* TraceID：已经在自己团队中使用，全公司级别的使用需要更多的协调
* 完整的调用链需要记录整个链路树，需要添加更多节点信息
* 链路太多会影响性能，需要平衡

### 消息队列Kafka
* 建立在文件系统上的顺序IO，高吞吐。
* 降低服务间的耦合。
* 非同步通信。
* 允许非同步的情况下，可以消除处理峰值压力。
* 可恢复性。
* 一定程度的时序保证

### Runtime
Runtime涉及了很多操作系统的知识，需要更多时间消化理解。

## 课程遗憾
### 时间不够
同时报了其他的训练营，再加上最近工作和家庭的事情比较多，每节课以后消化的时间不够。只有和工作内容紧密相关的部分得到了比较好的消化。只有等课程结束以后再继续了。好在视频一年内可以反复观看。

### 还有些内容没有讲到
* Go的逃逸分析：这是go性能调优的很关键的一个点。Go的内存分配在栈还是在堆上不是固定的，所以逃逸分析可以更好的帮助性能调优。相应的工具和细节没有讲。
* Pprof：也是Go性能分析的一个关键。使用上的一些套路，图表的解读。
* 反射机制：Go的反射机制很有用，但是使用不当会造成很多问题。这方面如果能有系统的讲解会很有帮助
